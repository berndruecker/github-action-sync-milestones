"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZeebeGrpcClient = void 0;
const fs_1 = require("fs");
const path = __importStar(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const promise_retry_1 = __importDefault(require("promise-retry"));
const typed_duration_1 = require("typed-duration");
const uuid_1 = require("uuid");
const lib_1 = require("../../lib");
const lib_2 = require("../lib");
const ConnectionFactory_1 = require("../lib/ConnectionFactory");
const ConnectionStatusEvent_1 = require("../lib/ConnectionStatusEvent");
const GrpcError_1 = require("../lib/GrpcError");
const SimpleLogger_1 = require("../lib/SimpleLogger");
const TypedEmitter_1 = require("../lib/TypedEmitter");
const ZBJsonLogger_1 = require("../lib/ZBJsonLogger");
const utils_1 = require("../lib/utils");
const ZBWorker_1 = require("./ZBWorker");
const debug = (0, debug_1.default)('camunda:zeebeclient');
const idColors = [
    chalk_1.default.yellow,
    chalk_1.default.green,
    chalk_1.default.cyan,
    chalk_1.default.magenta,
    chalk_1.default.blue,
];
/**
 * @description A client for interacting with a Zeebe broker. With the connection credentials set in the environment, you can use a "zero-conf" constructor with no arguments.
 * @example
 * ```
 * const zbc = new ZeebeGrpcClient()
 * zbc.topology().then(info =>
 *     console.log(JSON.stringify(info, null, 2))
 * )
 * ```
 */
class ZeebeGrpcClient extends TypedEmitter_1.TypedEmitter {
    constructor(options) {
        super();
        this.connected = undefined;
        this.readied = false;
        this.closing = false;
        this.workerCount = 0;
        this.workers = [];
        const config = lib_1.CamundaEnvironmentConfigurator.mergeConfigWithEnvironment(options?.config ?? {});
        this.config = config;
        this.options = {};
        this.options.longPoll = typed_duration_1.Duration.seconds.of(config.zeebeGrpcSettings.ZEEBE_GRPC_WORKER_LONGPOLL_SECONDS);
        this.options.pollInterval = typed_duration_1.Duration.milliseconds.of(config.zeebeGrpcSettings.ZEEBE_GRPC_WORKER_POLL_INTERVAL_MS);
        this.retry = config.zeebeGrpcSettings.ZEEBE_GRPC_CLIENT_RETRY;
        this.options.retry = this.retry;
        this.loglevel = config.zeebeGrpcSettings.ZEEBE_CLIENT_LOG_LEVEL;
        this.options.loglevel = this.loglevel;
        const logTypeFromEnvironment = () => ({
            JSON: ZBJsonLogger_1.ZBJsonLogger,
            SIMPLE: SimpleLogger_1.ZBSimpleLogger,
        })[config.zeebeGrpcSettings.ZEEBE_CLIENT_LOG_TYPE ?? 'NONE'];
        this.stdout = logTypeFromEnvironment() ?? SimpleLogger_1.ZBSimpleLogger;
        this.options.tenantId = config.CAMUNDA_TENANT_ID;
        this.tenantId = this.options.tenantId;
        this.gatewayAddress = (0, lib_1.RequireConfiguration)(config.ZEEBE_ADDRESS, 'ZEEBE_ADDRESS');
        debug('Gateway address: ', this.gatewayAddress);
        this.useTLS = config.CAMUNDA_SECURE_CONNECTION;
        const certChainPath = config.CAMUNDA_CUSTOM_CERT_CHAIN_PATH;
        const rootCertsPath = config.CAMUNDA_CUSTOM_ROOT_CERT_PATH;
        const privateKeyPath = config.CAMUNDA_CUSTOM_PRIVATE_KEY_PATH;
        const customSSL = {
            certChain: certChainPath ? (0, fs_1.readFileSync)(certChainPath) : undefined,
            privateKey: privateKeyPath ? (0, fs_1.readFileSync)(privateKeyPath) : undefined,
            rootCerts: rootCertsPath ? (0, fs_1.readFileSync)(rootCertsPath) : undefined,
        };
        this.customSSL = customSSL;
        this.options.customSSL = customSSL;
        this.connectionTolerance = typed_duration_1.Duration.milliseconds.of(config.zeebeGrpcSettings.ZEEBE_GRPC_CLIENT_CONNECTION_TOLERANCE_MS);
        this.onConnectionError = this.options.onConnectionError;
        this.onReady = this.options.onReady;
        this.oAuthProvider =
            options?.oAuthProvider ?? (0, lib_1.constructOAuthProvider)(config);
        const { grpcClient, log } = this.constructGrpcClient({
            grpcConfig: {
                namespace: this.options.logNamespace || 'ZBClient',
            },
            logConfig: {
                _tag: 'ZBCLIENT',
                loglevel: this.loglevel,
                longPoll: typed_duration_1.Duration.milliseconds.from(this.options.longPoll),
                namespace: this.options.logNamespace || 'ZBClient',
                pollInterval: typed_duration_1.Duration.milliseconds.from(this.options.pollInterval),
                stdout: this.stdout,
            },
        });
        grpcClient.on(ConnectionStatusEvent_1.ConnectionStatusEvent.connectionError, (err) => {
            if (this.connected !== false) {
                this.onConnectionError?.(err);
                this.emit(ConnectionStatusEvent_1.ConnectionStatusEvent.connectionError);
            }
            this.connected = false;
            this.readied = false;
        });
        grpcClient.on(ConnectionStatusEvent_1.ConnectionStatusEvent.ready, () => {
            if (!this.readied) {
                this.onReady?.();
                this.emit(ConnectionStatusEvent_1.ConnectionStatusEvent.ready);
            }
            this.connected = true;
            this.readied = true;
        });
        this.grpc = grpcClient;
        this.logger = log;
        this.maxRetries = config.zeebeGrpcSettings.ZEEBE_GRPC_CLIENT_MAX_RETRIES;
        this.maxRetryTimeout = typed_duration_1.Duration.seconds.of(config.zeebeGrpcSettings.ZEEBE_GRPC_CLIENT_MAX_RETRY_TIMEOUT_SECONDS);
        // Send command to broker to eagerly fail / prove connection.
        // This is useful for, for example: the Node-Red client, which wants to
        // display the connection status.
        const eagerConnection = config.zeebeGrpcSettings.ZEEBE_GRPC_CLIENT_EAGER_CONNECT;
        if (eagerConnection ?? false) {
            this.topology()
                .then((res) => {
                this.logger.logDirect(chalk_1.default.blueBright('Zeebe cluster topology:'));
                this.logger.logDirect(res.brokers);
            })
                .catch((e) => {
                // Swallow exception to avoid throwing if retries are off
                if (e.thisWillNeverHappenYo) {
                    this.emit(ConnectionStatusEvent_1.ConnectionStatusEvent.unknown);
                }
            });
        }
    }
    /**
     * @description activateJobs allows you to manually activate jobs, effectively building a worker; rather than using the ZBWorker class.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     * zbc.activateJobs({
     *   maxJobsToActivate: 5,
     *   requestTimeout: 6000,
     *   timeout: 5 * 60 * 1000,
     *   type: 'process-payment',
     *   worker: 'my-worker-uuid'
     * }).then(jobs =>
     * 	 jobs.forEach(job =>
     *     // business logic
     *     zbc.completeJob({
     *       jobKey: job.key,
     *       variables: {}
     *     ))
     *   )
     * })
     * ```
     */
    activateJobs(request) {
        const { inputVariableDto, customHeadersDto, ...req } = request;
        const inputVariableDtoToUse = inputVariableDto ??
            lib_1.LosslessDto;
        const customHeadersDtoToUse = customHeadersDto ??
            lib_1.LosslessDto;
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                const stream = await this.grpc.activateJobsStream(req);
                stream.on('data', (res) => {
                    const jobs = res.jobs.map((job) => (0, lib_2.parseVariablesAndCustomHeadersToJSON)(job, inputVariableDtoToUse, customHeadersDtoToUse));
                    resolve(jobs);
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     *
     * @description Broadcast a Signal
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     *
     * zbc.broadcastSignal({
     *   signalName: 'my-signal',
     *   variables: { reasonCode: 3 }
     * })
     */
    async broadcastSignal(req) {
        const request = {
            signalName: req.signalName,
            variables: JSON.stringify(req.variables ?? {}),
            tenantId: req.tenantId ?? this.tenantId,
        };
        return this.executeOperation('broadcastSignal', () => this.grpc.broadcastSignalSync(request));
    }
    /**
     *
     * @description Cancel a process instance by process instance key.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     *
     * zbc.cancelProcessInstance(processInstanceId)
     * 	.catch(
     * 		(e: any) => console.log(`Error cancelling instance: ${e.message}`)
     * )
     * ```
     */
    async cancelProcessInstance(processInstanceKey) {
        utils_1.Utils.validateNumber(processInstanceKey, 'processInstanceKey');
        return this.executeOperation('cancelProcessInstance', () => this.grpc.cancelProcessInstanceSync({
            processInstanceKey,
        }));
    }
    /**
     *
     * @description Create a worker that polls the gateway for jobs and executes a job handler when units of work are available.
     * @example
     * ```
     * const zbc = new ZB.ZeebeGrpcClient()
     *
     * const zbWorker = zbc.createWorker({
     *   taskType: 'demo-service',
     *   taskHandler: myTaskHandler,
     * })
     *
     * // A job handler must return one of job.complete, job.fail, job.error, or job.forward
     * // Note: unhandled exceptions in the job handler cause the library to call job.fail
     * async function myTaskHandler(job) {
     *   zbWorker.log('Task variables', job.variables)
     *
     *   // Task worker business logic goes here
     *   const updateToBrokerVariables = {
     *     updatedProperty: 'newValue',
     *   }
     *
     *   const res = await callExternalSystem(job.variables)
     *
     *   if (res.code === 'SUCCESS') {
     *     return job.complete({
     *        ...updateToBrokerVariables,
     *        ...res.values
     *     })
     *   }
     *   if (res.code === 'BUSINESS_ERROR') {
     *     return job.error({
     *       code: res.errorCode,
     *       message: res.message
     *     })
     *   }
     *   if (res.code === 'ERROR') {
     *     return job.fail({
     *        errorMessage: res.message,
     *        retryBackOff: 2000
     *     })
     *   }
     * }
     * ```
     */
    createWorker(config) {
        debug(`Creating worker for task type ${config.taskType}`);
        if (this.closing) {
            throw new Error('Client is closing. No worker creation allowed!');
        }
        const idColor = idColors[this.workerCount++ % idColors.length];
        // Merge parent client options with worker override
        const options = {
            ...this.options,
            onConnectionError: undefined, // Do not inherit client handler
            onReady: undefined, // Do not inherit client handler
            ...config,
        };
        // Give worker its own gRPC connection
        const { grpcClient: workerGRPCClient, log } = this.constructGrpcClient({
            grpcConfig: {
                namespace: 'ZBWorker',
                tasktype: config.taskType,
            },
            logConfig: {
                _tag: 'ZBWORKER',
                colorise: true,
                id: config.id,
                loglevel: options.loglevel,
                namespace: ['ZBWorker', options.logNamespace].join(' ').trim(),
                pollInterval: options.longPoll,
                stdout: options.stdout,
                taskType: config.taskType,
            },
        });
        const worker = new ZBWorker_1.ZBWorker({
            grpcClient: workerGRPCClient,
            id: config.id || null,
            idColor,
            log,
            options: { ...this.options, ...options },
            taskHandler: config.taskHandler,
            taskType: config.taskType,
            zbClient: this,
        });
        this.workers.push(worker);
        return worker;
    }
    /**
     * @description Gracefully shut down all workers, draining existing tasks, and return when it is safe to exit.
     *
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     *
     * zbc.createWorker({
     *   taskType:
     * })
     *
     * setTimeout(async () => {
     *   await zbc.close()
     *   console.log('All work completed.')
     * }),
     *   5 * 60 * 1000 // 5 mins
     * )
     * ```
     */
    async close(timeout) {
        this.closePromise =
            this.closePromise ||
                new Promise((resolve) => {
                    // Prevent the creation of more workers
                    this.closing = true;
                    Promise.all(this.workers.map((w) => w.close(timeout)))
                        .then(() => this.grpc.close(timeout))
                        .then(() => {
                        this.emit(ConnectionStatusEvent_1.ConnectionStatusEvent.close);
                        this.grpc.removeAllListeners();
                        this.removeAllListeners();
                        resolve(null);
                    });
                });
        return this.closePromise;
    }
    /**
     *
     * @description Explicitly complete a job. The method is useful for manually constructing a worker.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     * zbc.activateJobs({
     *   maxJobsToActivate: 5,
     *   requestTimeout: 6000,
     *   timeout: 5 * 60 * 1000,
     *   type: 'process-payment',
     *   worker: 'my-worker-uuid'
     * }).then(jobs =>
     * 	 jobs.forEach(job =>
     *     // business logic
     *     zbc.completeJob({
     *       jobKey: job.key,
     *       variables: {}
     *     ))
     *   )
     * })
     * ```
     */
    completeJob(completeJobRequest) {
        const withStringifiedVariables = (0, lib_2.stringifyVariables)(completeJobRequest);
        this.logger.logDebug(withStringifiedVariables);
        return this.executeOperation('completeJob', () => this.grpc.completeJobSync(withStringifiedVariables).catch((e) => {
            if (e.code === GrpcError_1.GrpcError.NOT_FOUND) {
                e.details +=
                    '. The process may have been cancelled, the job cancelled by an interrupting event, or the job already completed.' +
                        ' For more detail, see: https://forum.zeebe.io/t/command-rejected-with-code-complete/908/17';
            }
            throw e;
        }));
    }
    // tslint:disable: no-object-literal-type-assertion
    /**
     *
     * @description Create a new process instance. Asynchronously returns a process instance id.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     *
     * zbc.createProcessInstance({
     *   bpmnProcessId: 'onboarding-process',
     *   variables: {
     *     customerId: 'uuid-3455'
     *   },
     *   version: 5 // optional, will use latest by default
     * }).then(res => console.log(JSON.stringify(res, null, 2)))
     *
     * zbc.createProcessInstance({
     *   bpmnProcessId: 'SkipFirstTask',
     *   variables: { id: random },
     *   startInstructions: [{elementId: 'second_service_task'}]
     * }).then(res => (id = res.processInstanceKey))
     * ```
     */
    createProcessInstance(config) {
        const request = {
            bpmnProcessId: config.bpmnProcessId,
            variables: config.variables,
            version: config.version || -1,
            startInstructions: config.startInstructions || [],
        };
        const createProcessInstanceRequest = (0, lib_2.stringifyVariables)({
            ...request,
            startInstructions: request.startInstructions,
            tenantId: config.tenantId ?? this.tenantId,
        });
        return this.executeOperation('createProcessInstance', () => this.grpc.createProcessInstanceSync(createProcessInstanceRequest));
    }
    /**
     *
     * @description Create a process instance, and return a Promise that returns the outcome of the process.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     *
     * zbc.createProcessInstanceWithResult({
     *   bpmnProcessId: 'order-process',
     *   variables: {
     *     customerId: 123,
     *     invoiceId: 567
     *   }
     * })
     *   .then(console.log)
     * ```
     */
    createProcessInstanceWithResult(config) {
        const request = {
            bpmnProcessId: config.bpmnProcessId,
            fetchVariables: config.fetchVariables,
            requestTimeout: config.requestTimeout || 0,
            variables: config.variables,
            version: config.version || -1,
            tenantId: config.tenantId ?? this.tenantId,
        };
        const createProcessInstanceRequest = (0, lib_2.stringifyVariables)({
            bpmnProcessId: request.bpmnProcessId,
            variables: request.variables,
            version: request.version,
            tenantId: request.tenantId ?? this.tenantId,
        });
        return this.executeOperation('createProcessInstanceWithResult', () => this.grpc.createProcessInstanceWithResultSync({
            fetchVariables: request.fetchVariables,
            request: createProcessInstanceRequest,
            requestTimeout: request.requestTimeout,
        })).then((res) => (0, lib_2.parseVariables)(res));
    }
    /**
     * Delete a resource.
     * @param resourceId - The key of the resource that should be deleted. This can either be the key of a process definition, the key of a decision requirements definition or the key of a form.
     * @returns
     */
    deleteResource({ resourceKey, }) {
        return this.executeOperation('deleteResourceSync', () => this.grpc.deleteResourceSync({ resourceKey }));
    }
    async deployResource(resource) {
        const isProcess = (maybeProcess // eslint-disable-line @typescript-eslint/no-explicit-any
        ) => !!maybeProcess.process;
        const isProcessFilename = (maybeProcessFilename // eslint-disable-line @typescript-eslint/no-explicit-any
        ) => !!maybeProcessFilename.processFilename;
        const isDecision = (maybeDecision // eslint-disable-line @typescript-eslint/no-explicit-any
        ) => !!maybeDecision.decision;
        const isDecisionFilename = (maybeDecisionFilename // eslint-disable-line @typescript-eslint/no-explicit-any
        ) => !!maybeDecisionFilename.decisionFilename;
        // default fall-through
        /* const isForm = ( maybeForm: any ): maybeForm is { form: Buffer; name: string } =>
            !!maybeForm.form
            */
        const isFormFilename = (maybeFormFilename // eslint-disable-line @typescript-eslint/no-explicit-any
        ) => !!maybeFormFilename.formFilename;
        if (isProcessFilename(resource)) {
            const filename = resource.processFilename;
            const process = (0, fs_1.readFileSync)(filename);
            return this.executeOperation('deployResource', () => this.grpc.deployResourceSync({
                resources: [
                    {
                        name: filename,
                        content: process,
                    },
                ],
                tenantId: resource.tenantId ?? this.tenantId,
            }));
        }
        else if (isProcess(resource)) {
            return this.executeOperation('deployResource', () => this.grpc.deployResourceSync({
                resources: [
                    {
                        name: resource.name,
                        content: resource.process,
                    },
                ],
                tenantId: resource.tenantId ?? this.tenantId,
            }));
        }
        else if (isDecisionFilename(resource)) {
            const filename = resource.decisionFilename;
            const decision = (0, fs_1.readFileSync)(filename);
            return this.executeOperation('deployResource', () => this.grpc.deployResourceSync({
                resources: [
                    {
                        name: filename,
                        content: decision,
                    },
                ],
                tenantId: resource.tenantId ?? this.tenantId,
            }));
        }
        else if (isDecision(resource)) {
            return this.executeOperation('deployResource', () => this.grpc.deployResourceSync({
                resources: [
                    {
                        name: resource.name,
                        content: resource.decision,
                    },
                ],
                tenantId: resource.tenantId ?? this.tenantId,
            }));
        }
        else if (isFormFilename(resource)) {
            const filename = resource.formFilename;
            const form = (0, fs_1.readFileSync)(filename);
            return this.executeOperation('deployResource', () => this.grpc.deployResourceSync({
                resources: [
                    {
                        name: filename,
                        content: form,
                    },
                ],
                tenantId: resource.tenantId ?? this.tenantId,
            }));
        } /* if (isForm(resource)) */
        else {
            // default fall-through
            return this.executeOperation('deployResource', () => this.grpc.deployResourceSync({
                resources: [
                    {
                        name: resource.name,
                        content: resource.form,
                    },
                ],
                tenantId: resource.tenantId ?? this.tenantId,
            }));
        }
    }
    /**
     *
     * @description Evaluates a decision. The decision to evaluate can be specified either by using its unique key (as returned by DeployResource), or using the decision ID. When using the decision ID, the latest deployed version of the decision is used.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     * zbc.evaluateDecision({
     *   decisionId: 'my-decision',
     *   variables: { season: "Fall" }
     * }).then(res => console.log(JSON.stringify(res, null, 2)))
     */
    evaluateDecision(evaluateDecisionRequest) {
        // the gRPC API call needs a JSON string, but we accept a JSON object, so we transform it here
        const variables = (0, lib_1.losslessStringify)(evaluateDecisionRequest.variables);
        return this.executeOperation('evaluateDecision', () => this.grpc.evaluateDecisionSync({
            ...evaluateDecisionRequest,
            variables,
            tenantId: evaluateDecisionRequest.tenantId ?? this.tenantId,
        }));
    }
    /**
     *
     * @description Fail a job. This is useful if you are using the decoupled completion pattern or building your own worker.
     * For the retry count, the current count is available in the job metadata.
     *
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     * zbc.failJob( {
     *   jobKey: '345424343451',
     *   retries: 3,
     *   errorMessage: 'Could not get a response from the order invoicing API',
     *   retryBackOff: 30 * 1000 // optional, otherwise available for reactivation immediately
     * })
     * ```
     */
    failJob(failJobRequest) {
        return this.executeOperation('failJob', () => this.grpc.failJobSync(failJobRequest));
    }
    /**
     * @description Return an array of task types contained in a BPMN file or array of BPMN files. This can be useful, for example, to do
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     * zbc.getServiceTypesFromBpmn(['bpmn/onboarding.bpmn', 'bpmn/process-sale.bpmn'])
     *   .then(tasktypes => console.log('The task types are:', tasktypes))
     *
     * ```
     */
    getServiceTypesFromBpmn(files) {
        const fileArray = typeof files === 'string' ? [files] : files;
        return lib_2.BpmnParser.getTaskTypes(lib_2.BpmnParser.parseBpmn(fileArray));
    }
    /**
     *
     * @description Modify a running process instance. This allows you to move the execution tokens, and change the variables. Added in 8.1.
     * See the [gRPC protocol documentation](https://docs.camunda.io/docs/apis-clients/grpc/#modifyprocessinstance-rpc).
     * @example
     * ```
     * zbc.createProcessInstance('SkipFirstTask', {}).then(res =>
     *   zbc.modifyProcessInstance({
     *     processInstanceKey: res.processInstanceKey,
     *     activateInstructions: [{
     *       elementId: 'second_service_task',
     *       ancestorElementInstanceKey: "-1",
     *       variableInstructions: [{
     *         scopeId: '',
     *         variables: { second: 1}
     *       }]
     *     }]
     *   })
     * )
     * ```
     */
    modifyProcessInstance(modifyProcessInstanceRequest) {
        return this.executeOperation('modifyProcessInstance', () => {
            // We accept JSONDoc for the variableInstructions, but the actual gRPC call needs stringified JSON, so transform it with a mutation
            const req = utils_1.Utils.deepClone(modifyProcessInstanceRequest);
            req?.activateInstructions?.forEach((a) => a.variableInstructions.forEach((v) => (v.variables = (0, lib_1.losslessStringify)(v.variables))));
            return this.grpc.modifyProcessInstanceSync({
                ...req,
            });
        });
    }
    /**
     *
     * @since 8.5.0
     */
    migrateProcessInstance(migrateProcessInstanceRequest) {
        return this.executeOperation('migrateProcessInstance', () => this.grpc.migrateProcessInstanceSync(migrateProcessInstanceRequest));
    }
    /**
     * @description Publish a message to the broker for correlation with a workflow instance. See [this tutorial](https://docs.camunda.io/docs/guides/message-correlation/) for a detailed description of message correlation.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     *
     * zbc.publishMessage({
     *   // Should match the "Message Name" in a BPMN Message Catch
     *   name: 'order_status',
     *   correlationKey: 'uuid-124-532-5432',
     *   variables: {
     *     event: 'PROCESSED'
     *   }
     * })
     * ```
     */
    publishMessage(publishMessageRequest) {
        return this.executeOperation('publishMessage', () => this.grpc.publishMessageSync((0, lib_2.stringifyVariables)({
            ...publishMessageRequest,
            variables: publishMessageRequest.variables,
            tenantId: publishMessageRequest.tenantId ?? this.tenantId,
        })));
    }
    /**
     * @description Publish a message to the broker for correlation with a workflow message start event.
     * For a message targeting a start event, the correlation key is not needed to target a specific running process instance.
     * However, the hash of the correlationKey is used to determine the partition where this workflow will start.
     * So we assign a random uuid to balance workflow instances created via start message across partitions.
     *
     * We make the correlationKey optional, because the caller can specify a correlationKey + messageId
     * to guarantee an idempotent message.
     *
     * Multiple messages with the same correlationKey + messageId combination will only start a workflow once.
     * See: https://github.com/zeebe-io/zeebe/issues/1012 and https://github.com/zeebe-io/zeebe/issues/1022
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     * zbc.publishStartMessage({
     *   name: 'Start_New_Onboarding_Flow',
     *   variables: {
     *     customerId: 'uuid-348-234-8908'
     *   }
     * })
     *
     * // To do the same in an idempotent fashion - note: only idempotent during the lifetime of the created instance.
     * zbc.publishStartMessage({
     *   name: 'Start_New_Onboarding_Flow',
     *   messageId: 'uuid-348-234-8908', // use customerId to make process idempotent per customer
     *   variables: {
     *     customerId: 'uuid-348-234-8908'
     *   }
     * })
     * ```
     */
    publishStartMessage(publishStartMessageRequest) {
        /**
         * The hash of the correlationKey is used to determine the partition where this workflow will start.
         * So we assign a random uuid to balance workflow instances created via start message across partitions.
         *
         * We make the correlationKey optional, because the caller can specify a correlationKey + messageId
         * to guarantee an idempotent message.
         *
         * Multiple messages with the same correlationKey + messageId combination will only start a workflow once.
         * See: https://github.com/zeebe-io/zeebe/issues/1012 and https://github.com/zeebe-io/zeebe/issues/1022
         */
        const publishMessageRequest = {
            correlationKey: (0, uuid_1.v4)(),
            ...publishStartMessageRequest,
            tenantId: publishStartMessageRequest.tenantId ?? this.tenantId,
        };
        return this.executeOperation('publishStartMessage', () => this.grpc.publishMessageSync((0, lib_2.stringifyVariables)({
            ...publishMessageRequest,
            variables: publishMessageRequest.variables || {},
        })));
    }
    /**
     *
     * @description Resolve an incident by incident key.
     * @example
     * ```
     * type JSONObject = {[key: string]: string | number | boolean | JSONObject}
     *
     * const zbc = new ZeebeGrpcClient()
     *
     * async updateAndResolveIncident({
     *   processInstanceId,
     *   incidentKey,
     *   variables
     * } : {
     *   processInstanceId: string,
     *   incidentKey: string,
     *   variables: JSONObject
     * }) {
     *   await zbc.setVariables({
     *     elementInstanceKey: processInstanceId,
     *     variables
     *   })
     *   await zbc.updateRetries()
     *   zbc.resolveIncident({
     *     incidentKey
     *   })
     *   zbc.resolveIncident(incidentKey)
     * }
     *
     * ```
     */
    resolveIncident(resolveIncidentRequest) {
        return this.executeOperation('resolveIncident', () => this.grpc.resolveIncidentSync(resolveIncidentRequest));
    }
    /**
     *
     * @description Directly modify the variables is a process instance. This can be used with `resolveIncident` to update the process and resolve an incident.
     * @example
     * ```
     * type JSONObject = {[key: string]: string | number | boolean | JSONObject}
     *
     * const zbc = new ZeebeGrpcClient()
     *
     * async function updateAndResolveIncident({
     *   incidentKey,
     *   processInstanceKey,
     *   jobKey,
     *   variableUpdate
     * } : {
     *   incidentKey: string
     *   processInstanceKey: string
     *   jobKey: string
     *   variableUpdate: JSONObject
     * }) {
     *   await zbc.setVariables({
     *     elementInstanceKey: processInstanceKey,
     *     variables: variableUpdate
     *   })
     *   await zbc.updateJobRetries({
     *     jobKey,
     *     retries: 1
     *   })
     *   return zbc.resolveIncident({
     *     incidentKey
     *   })
     * }
     * ```
     */
    setVariables(request) {
        /*
        We allow developers to interact with variables as a native JS object, but the Zeebe server needs it as a JSON document
        So we stringify it here.
        */
        const variables = typeof request.variables === 'object'
            ? (0, lib_1.losslessStringify)(request.variables)
            : request.variables;
        return this.executeOperation('setVariables', () => this.grpc.setVariablesSync({ ...request, variables }));
    }
    /**
     *
     * @description Fail a job by throwing a business error (i.e. non-technical) that occurs while processing a job.
     * The error is handled in the workflow by an error catch event.
     * If there is no error catch event with the specified `errorCode` then an incident will be raised instead.
     * This method is useful when building a worker, for example for the decoupled completion pattern.
     * @example
     * ```
     * type JSONObject = {[key: string]: string | number | boolean | JSONObject}
     *
     * interface errorResult {
     *   resultType: 'ERROR' as 'ERROR'
     * 	 errorCode: string
     *   errorMessage: string
     * }
     *
     * interface successResult {
     *   resultType: 'SUCCESS' as 'SUCCESS'
     *   variableUpdate: JSONObject
     * }
     *
     * type Result = errorResult | successResult
     *
     * const zbc = new ZeebeGrpcClient()
     *
     *
     * // This could be a listener on a return queue from an external system
     * async function handleJob(jobKey: string, result: Result) {
     *   if (resultType === 'ERROR') {
     *     const { errorMessage, errorCode } = result
     * 		zbc.throwError({
     *        jobKey,
     *        errorCode,
     * 		  errorMessage
     *     })
     *   } else {
     *     zbc.completeJob({
     *       jobKey,
     *       variables: result.variableUpdate
     *     })
     *   }
     * }
     * ```
     */
    throwError(throwErrorRequest) {
        const req = (0, lib_2.stringifyVariables)({
            ...throwErrorRequest,
            variables: throwErrorRequest.variables ?? {},
        });
        return this.executeOperation('throwError', () => this.grpc.throwErrorSync(req));
    }
    /**
     * @description Return the broker cluster topology.
     * @example
     * ```
     * const zbc = new ZeebeGrpcClient()
     *
     * zbc.topology().then(res => console.res(JSON.stringify(res, null, 2)))
     * ```
     */
    topology() {
        return this.executeOperation('topology', this.grpc.topologySync);
    }
    /**
     *
     * @description Update the number of retries for a Job. This is useful if a job has zero remaining retries and fails, raising an incident.
     * @example
     * ```
     * type JSONObject = {[key: string]: string | number | boolean | JSONObject}
     *
     * const zbc = new ZeebeGrpcClient()
     *
     * async function updateAndResolveIncident({
     *   incidentKey,
     *   processInstanceKey,
     *   jobKey,
     *   variableUpdate
     * } : {
     *   incidentKey: string
     *   processInstanceKey: string
     *   jobKey: string
     *   variableUpdate: JSONObject
     * }) {
     *   await zbc.setVariables({
     *     elementInstanceKey: processInstanceKey,
     *     variables: variableUpdate
     *   })
     *   await zbc.updateJobRetries({
     *     jobKey,
     *     retries: 1
     *   })
     *   return zbc.resolveIncident({
     *     incidentKey
     *   })
     * }
     * ```
     */
    updateJobRetries(updateJobRetriesRequest) {
        return this.executeOperation('updateJobRetries', () => this.grpc.updateJobRetriesSync(updateJobRetriesRequest));
    }
    constructGrpcClient({ grpcConfig, logConfig, }) {
        const { grpcClient, log } = ConnectionFactory_1.ConnectionFactory.getGrpcClient({
            grpcConfig: {
                config: this.config,
                connectionTolerance: typed_duration_1.Duration.milliseconds.from(this.connectionTolerance),
                customSSL: this.customSSL,
                host: this.gatewayAddress,
                loglevel: this.loglevel,
                namespace: grpcConfig.namespace,
                oAuth: this.oAuthProvider,
                options: {
                    longPoll: this.options.longPoll
                        ? typed_duration_1.Duration.milliseconds.from(this.options.longPoll)
                        : undefined,
                },
                packageName: 'gateway_protocol',
                protoPath: path.join(__dirname, '../../proto/zeebe.proto'),
                service: 'Gateway',
                stdout: this.stdout,
                tasktype: grpcConfig.tasktype,
                useTLS: this.useTLS,
            },
            logConfig,
        });
        if (grpcConfig.onConnectionError) {
            grpcClient.on(ConnectionStatusEvent_1.ConnectionStatusEvent.connectionError, grpcConfig.onConnectionError);
        }
        if (grpcConfig.onReady) {
            grpcClient.on(ConnectionStatusEvent_1.ConnectionStatusEvent.ready, grpcConfig.onReady);
        }
        return { grpcClient: grpcClient, log };
    }
    /**
     * If this.retry is set true, the operation will be wrapped in an configurable retry on exceptions
     * of gRPC error code 14 - Transient Network Failure.
     * See: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
     * If this.retry is false, it will be executed with no retry, and the application should handle the exception.
     * @param operation A gRPC command operation
     */
    async executeOperation(operationName, operation, retries) {
        return this.retry
            ? this.retryOnFailure({ operationName, operation, retries })
            : this.retryOnFailure({ operationName, operation, retries: 0 });
    }
    _onConnectionError(err) {
        if (!this.connected) {
            return;
        }
        this.connected = false;
        // const debounce =
        // 	this.lastConnectionError &&
        // 	new Date().valueOf() - this.lastConnectionError.valueOf() >
        // 		this.connectionTolerance / 2
        // if (!debounce) {
        this.onConnectionError?.(err);
        this.emit(ConnectionStatusEvent_1.ConnectionStatusEvent.connectionError);
        // }
        // this.lastConnectionError = new Date()
    }
    /**
     * This function takes a gRPC operation that returns a Promise as a function, and invokes it.
     * If the operation throws gRPC error 14, this function will continue to try it until it succeeds
     * or retries are exhausted.
     * @param operation A gRPC command operation that may fail if the broker is not available
     */
    async retryOnFailure({ operation, operationName, retries = this.maxRetries, }) {
        let connectionErrorCount = 0;
        let authFailures = 0;
        return (0, promise_retry_1.default)((retry, n) => {
            if (this.closing || this.grpc.channelClosed) {
                /**
                 * Should we reject instead? The idea here is that calling ZBClient.close() will allow the application to cleanly shut down.
                 * If we reject here, any pending calls will throw errors. This is probably not what the user is expecting to see.
                 */
                return Promise.resolve(null);
            }
            if (n > 1) {
                this.logger.logError(`[${operationName}]: Attempt ${n} (max: ${this.maxRetries}).`);
            }
            return operation().catch((err) => {
                // This could be DNS resolution, or the gRPC gateway is not reachable yet, or Backpressure
                const isNetworkError = (err.message.indexOf('14') === 0 ||
                    err.message.indexOf('Stream removed') !== -1) &&
                    !err.message.includes('partition'); // Error 14 can be host unavailable (network) or partition unavailable (not network)
                const isBackpressure = err.message.indexOf('8') === 0 || err.code === 8;
                const isAuthError = err.message.indexOf('16') === 0;
                if (isNetworkError) {
                    if (connectionErrorCount < 0) {
                        this._onConnectionError(err);
                    }
                    connectionErrorCount++;
                }
                if (isNetworkError || isBackpressure) {
                    this.logger.logError(`[${operationName}]: ${err.message}`);
                    retry(err);
                }
                // We will retry once, and only once for an auth error. This may be due to a token
                // expiry edge-case.
                // See https://github.com/camunda/camunda-8-js-sdk/issues/125
                if (isAuthError && authFailures === 0) {
                    authFailures = 1;
                    retry(err);
                }
                // The gRPC channel will be closed if close has been called
                if (this.grpc.channelClosed) {
                    return Promise.resolve(null);
                }
                throw err;
            });
        }, {
            forever: retries === -1,
            maxTimeout: typed_duration_1.Duration.milliseconds.from(this.maxRetryTimeout),
            retries: retries === -1 ? undefined : retries,
        });
    }
}
exports.ZeebeGrpcClient = ZeebeGrpcClient;
//# sourceMappingURL=ZeebeGrpcClient.js.map